<!DOCTYPE html> <html lang=en > <style> #cppn{ position:absolute; top:0; bottom:0; height: 100%; width: 100vw; } iframe { display: block; border-style:none; } </style> <meta property="og:title" content=Flux.jl > <meta property="og:description" content="The elegant machine learning library"> <meta property="og:image" content="/assets/images/FluxGitHubPreview.png"> <meta property="og:url" content=fluxml.ai > <meta name="twitter:title" content=Flux.jl > <meta name="twitter:description" content="The elegant machine learning library"> <meta name="twitter:image" content="/assets/images/FluxGitHubPreview.png"> <meta name="twitter:card" content=summary_large_image > <link rel=apple-touch-icon  sizes=180x180  href="assets/favicon_io/apple-touch-icon.png"> <link rel=icon  type="image/png" sizes=32x32  href="assets/favicon_io/favicon-32x32.png"> <link rel=icon  type="image/png" sizes=16x16  href="assets/favicon_io/favicon-16x16.png"> <link rel=manifest  href="assets/favicon_io/site.webmanifest"> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-36890222-9"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-36890222-9'); </script> <meta charset=utf-8 > <meta name=viewport  content="width=device-width, initial-scale=1, shrink-to-fit=no"> <link rel=stylesheet  href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta/css/bootstrap.min.css" integrity="sha384-/Y6pD6FV/Vv2HJnA6t+vslU6fwYXjCFtcEpHbNJ0lyAFsXTsjBbfaDjzALeQsN6M" crossorigin=anonymous > <link rel=stylesheet  href="../../css/script_default.css"> <link rel=stylesheet  href="../../css/site.css"> <link rel=stylesheet  href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin=anonymous > <link rel=stylesheet  href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css" integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y" crossorigin=anonymous > <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.js" integrity="sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx" crossorigin=anonymous ></script> <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/auto-render.min.js" integrity="sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe" crossorigin=anonymous  onload="renderMathInElement(document.body, { delimiters: [ {left: '$[[', right: ']]', display: true}, {left: '\\[', right: '\\]', display: true}, {left: '[[', right: ']]', display: false} ] });"> </script> <title>Flux – Elegant ML</title> <nav class="navbar navbar-expand-lg navbar-dark container lighter"> <a class=navbar-brand  href="/./"> <div class=logo  style="font-size:30pt;margin-top:-15px;margin-bottom:-10px;">flux</div> </a> <button class=navbar-toggler  type=button  data-toggle=collapse  data-target="#navbarSupportedContent" aria-controls=navbarSupportedContent  aria-expanded=false  aria-label="Toggle navigation"> <span class=navbar-toggler-icon ></span> </button> <div class="collapse navbar-collapse" id=navbarSupportedContent > <ul class="navbar-nav mr-auto"> <li class=nav-item > <a class=nav-link  href="https://fluxml.ai/Flux.jl/" target=_blank >Documentation</a> <li class=nav-item > <a class=nav-link  href="https://github.com/FluxML/model-zoo/" target=_blank >Model Zoo</a> <li class=nav-item > <a class=nav-link  href="https://github.com/FluxML/Flux.jl" target=_blank >GitHub</a> <li class=nav-item > <a class=nav-link  href="https://fluxml.ai/Flux.jl/stable/ecosystem/">Ecosystem</a> <!-- <li class=nav-item > <a class=nav-link  href="/./gsod/">GSoD</a> --> <li class=nav-item > <a class=nav-link  href="/./blog/">Blog</a> <li class=nav-item > <a class=nav-link  href="/./gsoc/">GSoC</a> <li> <a class=nav-link  href="/./governance/">Governance</a> <li class=nav-item > <a class=nav-link  href="https://github.com/FluxML/Flux.jl/blob/master/CONTRIBUTING.md" target=_blank >Contribute</a> </ul> </div> </nav> <div class=content > <div class=container > <h1>Flux3D.jl, 3D Vision Library in Julia</h1> <div class=franklin-content > <p>3D computer vision involves various computer vision techniques like classification, segmentation, object detection, super-resolution and many more. Modeling these problems becomes significantly easier when there is a general purpose differentiation library available, alongside the litany of tools needed to solve a train ML model, which FluxML already supports.</p> <p>Performing 3D vision tasks involve preparing datasets to fit a certain representation and applying transforms to them. Further, Flux3D exports common 3D metrics for use in designing the loss objective and various 3D layers, which have been optimised for performance for large datasets, typical in vision-based tasks.</p> <h2 id=what_is_flux3djl ><a href="#what_is_flux3djl" class=header-anchor >What is Flux3D.jl</a></h2> <div style="text-align:center"> <img width=400  src="../../assets/blogposts/2020-12-20-Flux3D/visualize_anim.gif"> </div> <p>Flux3D.jl is a 3D vision library, written completely in Julia. This package utilizes Flux.jl and Zygote.jl as its building blocks for training 3D vision models and for supporting differentiation. This package also has the support of CUDA GPU acceleration with CUDA.jl. Some of the roles of Flux3D are:</p> <ul> <li><p>3D Structures - Accelerated Batched Data structure for PointCloud, VoxelGrid and TriMesh for storing and computation.</p> <li><p>Transforms - Multiple transforms for PointCloud, VoxelGrid and TriMesh</p> <li><p>Metrics - metrics like chamfer_distance, laplacian loss and edge loss for defining loss objectives.</p> <li><p>Dataset - ModelNet10/40 &#40;in multiple variants like pointcloud, mesh, voxel&#41; and a Minimal Custom Dataset wrapper.</p> <li><p>Conversions - Interconversion between different 3D structure &#40;this also help in building different variants of the dataset&#41;</p> <li><p>Visualize - visualizing PointCloud, TriMesh and VoxelGrid</p> <li><p>3D Deep Learning - Implementations of some commonly used 3D layers and models.</p> </ul> <p>Flux3D.jl : <a href="https://github.com/FluxML/Flux3D.jl">github.com/FluxML/Flux3D.jl</a></p> <p>Docs : <a href="https://fluxml.ai/Flux3D.jl/stable">fluxml.ai/Flux3D.jl/stable</a></p> <h2 id=benchmarks_for_flux3djl ><a href="#benchmarks_for_flux3djl" class=header-anchor >Benchmarks for Flux3D.jl</a></h2> <p>Kaolin is a popular 3D vision library based on PyTorch. Flux3D.jl is overall faster than Kaolin in terms of applying transforms on PointCloud/TriMesh and comparable with Kaolin in terms of applying metrics. However, there must be work done to improve the back pass in laplacian loss which uses <code>SparseArrays</code>. From the benchmarks, we can tell that Flux3D can outperform Kaolin. Some key-differences between the two are discussed later in this post.</p> <p float=middle > <img src="../../assets/blogposts/2020-12-20-Flux3D/bm_pcloud.png"> <img src="../../assets/blogposts/2020-12-20-Flux3D/bm_trimesh.png"> <img src="../../assets/blogposts/2020-12-20-Flux3D/bm_metrics.png"> </p> <h2 id=short_walkthrough_of_the_flux3djl ><a href="#short_walkthrough_of_the_flux3djl" class=header-anchor >Short Walkthrough of the Flux3D.jl</a></h2> <p>A basic training pipeline requires preparing the datasets, defining the model, the loss function and finally training it. Let&#39;s go through each step along with visualising and evaluating the results.</p> <h3 id=handling_3d_datapoint ><a href="#handling_3d_datapoint" class=header-anchor ><ol> <li><p>Handling 3D DataPoint</p> </ol> </a></h3> <p>Pointcloud, triangle mesh and voxels are three widely used representation for 3D data and most of the 3D vision work is also based on these structures. To apply transforms to our data, we need to initialise it. </p> <pre><code class="julia hljs">julia&gt; <span class=hljs-keyword >using</span> Flux3D

julia&gt; m = load_trimesh(<span class=hljs-string >&quot;airplane.off&quot;</span>, <span class=hljs-string >&quot;teapot.obj&quot;</span>) |&gt; gpu
TriMesh{<span class=hljs-built_in >Float32</span>, <span class=hljs-built_in >UInt32</span>, CUDA.CuArray} Structure:
    Batch size: <span class=hljs-number >2</span>
    Max verts: <span class=hljs-number >17443</span>
    Max faces: <span class=hljs-number >17116</span>
    offset: -<span class=hljs-number >1</span>
    Storage type: CuArray

julia&gt; p = PointCloud(m)
PointCloud{<span class=hljs-built_in >Float32</span>} Structure:
    Batch size: <span class=hljs-number >2</span>
    Points: <span class=hljs-number >3000</span>
    Normals: <span class=hljs-number >0</span>
    Storage type: CuArray{<span class=hljs-built_in >Float32</span>,<span class=hljs-number >3</span>}

julia&gt; v = VoxelGrid(m)
VoxelGrid{<span class=hljs-built_in >Float32</span>} Structure:
    Batch size: <span class=hljs-number >2</span>
    Voxels features: <span class=hljs-number >64</span>
    Storage type: CuArray{<span class=hljs-built_in >Float32</span>,<span class=hljs-number >4</span>}

julia&gt; t = NormalizeTriMesh(inplace=<span class=hljs-literal >false</span>)
NormalizeTriMesh(;inplace=<span class=hljs-literal >false</span>)

julia&gt; m2 = t(m)
TriMesh{<span class=hljs-built_in >Float32</span>, <span class=hljs-built_in >UInt32</span>, CUDA.CuArray} Structure:
    Batch size: <span class=hljs-number >2</span>
    Max verts: <span class=hljs-number >17443</span>
    Max faces: <span class=hljs-number >17116</span>
    offset: -<span class=hljs-number >1</span>
    Storage type: CuArray

julia&gt; save_trimesh(<span class=hljs-string >&quot;normalize_aiplane.obj&quot;</span>,m2,<span class=hljs-number >1</span>)</code></pre> <h3 id=ol_start2_preparing_dataset ><a href="#ol_start2_preparing_dataset" class=header-anchor ><ol start=2 > <li><p>Preparing Dataset</p> </ol> </a></h3> <p>ModelNet10/40 is one of the widely used 3D dataset, and we can easily access and preprocess this dataset for use in various vision-based tasks using Flux3D. We can also use conversion transforms for using ModelNet10/40 in multiple representations like <code>PointCloud</code>, <code>TriMesh</code>, <code>VoxelGrid</code>.</p> <pre><code class="julia hljs">julia&gt; <span class=hljs-keyword >using</span> Flux3D, Makie

julia&gt; dset = ModelNet10(categories=[<span class=hljs-string >&quot;monitor&quot;</span>,<span class=hljs-string >&quot;chair&quot;</span>])
ModelNet Dataset:
    root: /root/.julia/packages/Flux3D/<span class=hljs-number >9</span>bMbc/datasets/
    train: <span class=hljs-literal >true</span>
    length: <span class=hljs-number >1354</span>
    transform: <span class=hljs-literal >nothing</span>
    categories: <span class=hljs-number >2</span>

julia&gt; dset[<span class=hljs-number >1</span>]
DataPoint:
    idx: <span class=hljs-number >1</span>
    data: TriMesh{<span class=hljs-built_in >Float32</span>,<span class=hljs-built_in >UInt32</span>,<span class=hljs-built_in >Array</span>}
    ground_truth: <span class=hljs-number >1</span>
    category_name: monitor</code></pre> <p>We can use conversion transforms to convert the dataset to <code>VoxelGrid</code>. Similarily we can convert <code>VoxelGrid</code>, <code>TriMesh</code> and <code>PointCloud</code> to any 3D structure either using transforms or simply using the regular constructor.</p> <pre><code class="julia hljs">julia&gt; t = Chain(NormalizeTriMesh(), TriMeshToVoxelGrid(<span class=hljs-number >64</span>))
Chain(NormalizeTriMesh(;inplace=<span class=hljs-literal >true</span>), TriMeshToVoxelGrid(resolution=<span class=hljs-number >64</span>))

julia&gt; dset2 = ModelNet10(train=<span class=hljs-literal >false</span>, transform=t)
dset2 = ModelNet Dataset:
    root: /root/.julia/packages/Flux3D/<span class=hljs-number >9</span>bMbc/datasets/
    train: <span class=hljs-literal >false</span>
    length: <span class=hljs-number >908</span>
    transform: Chain(NormalizeTriMesh(;inplace=<span class=hljs-literal >true</span>), TriMeshToVoxelGrid(resolution=<span class=hljs-number >64</span>))
    categories: <span class=hljs-number >10</span>

julia&gt; dset2[<span class=hljs-number >1</span>]
DataPoint:
    idx: <span class=hljs-number >1</span>
    data: VoxelGrid{<span class=hljs-built_in >Float32</span>}
    ground_truth: <span class=hljs-number >1</span>
    category_name: bathtub</code></pre> <h3 id=ol_start3_defining_modelloss ><a href="#ol_start3_defining_modelloss" class=header-anchor ><ol start=3 > <li><p>Defining Model/Loss</p> </ol> </a></h3> <p>Loss objectives and designing model solely depend upon the requirement of tasks, and with the help of FLuxML ecosystem, we can define any custom model as well as loss. There are some commonly used metrics and predefined 3D models which can assist in 3D specific tasks like chamfer<em>distance, laplacian</em>loss and edge_loss. </p> <pre><code class="julia hljs">julia&gt; chamfer_distance(p,p)
<span class=hljs-number >1.58147f-5</span>

julia&gt; laplacian_loss(m)
<span class=hljs-number >6.72288</span>

julia&gt; edge_loss(m)
<span class=hljs-number >2110.6</span></code></pre> <h3 id=ol_start4_training ><a href="#ol_start4_training" class=header-anchor ><ol start=4 > <li><p>Training</p> </ol> </a></h3> <p>Flux and Zygote takes care of everything here :&#41;</p> <p>Additonally, 3D structures and all relevant transforms, as well as metrics, are compatible with Zygote for supporting differentiation.</p> <div style="text-align:center"> <img width=300  src="../../assets/blogposts/2020-12-20-Flux3D/fitmesh_anim.gif"> </div> <h3 id=ol_start5_visualization_and_evaluation ><a href="#ol_start5_visualization_and_evaluation" class=header-anchor ><ol start=5 > <li><p>Visualization and Evaluation</p> </ol> </a></h3> <p>Flux3D provides a function visualize for visualizing 3D structures. This function uses Makie for plotting. We can use this same function for visualizing all three 3D structures PointCloud, TriMesh, and VoxelGrid</p> <pre><code class="julia hljs">julia&gt; <span class=hljs-keyword >using</span> Makie

julia&gt; vbox(
    hbox(
        visualize(m,<span class=hljs-number >1</span>),visualize(p,<span class=hljs-number >1</span>,markersize=<span class=hljs-number >25</span>)
        ),
    hbox(
        visualize(v,<span class=hljs-number >1</span>), visualize(v,<span class=hljs-number >1</span>,algo=:MarchingCubes)
        ),
    )</code></pre> <div style="text-align:center"> <img src="../../assets/blogposts/2020-12-20-Flux3D/visualize.png"> </div> <h2 id=why_use_julia_and_fluxml_ecosystem ><a href="#why_use_julia_and_fluxml_ecosystem" class=header-anchor >Why use Julia and FluxML ecosystem</a></h2> <p>Kaolin is written majorly in the lower language C&#43;&#43; and uses CUDA-C for using GPU which is integrated with python for API interface. But with Flux3D, it is written purely in Julia and with the help of <strong>CUDA.jl</strong> we are also able to leverage GPU acceleration with the same code. This surely emphasizes the benefit of using Julia Language for intense computation like 3D vision while using high-level functions like any other modern language.</p> <p><strong>FluxML</strong> ecosystem uses <strong>Zygote</strong> as the AD engine which doesn&#39;t require the input and variable to be present in any special form &#40;like Tensors in PyTorch&#41;, instead, we can simply define a function without doing mutation and Zygote will calculate gradients for us. Therefore we can make this package compatible with FluxML ecosystem without doing any extra work and even with many other packages like SciML differential equations ecosystem.</p> <p>There are various Julia packages &#40;thanks to awesome Julia community&#33;&#41; which make Flux3D.jl possible. With the help of <strong>Makie</strong> ecosystem, we can easily interact, visualize 3D structures, save the plots and gifs. <strong>NearestNeighbors.jl</strong> which is high performance nearest neighbour search library also makes it possible to perform intense computation metrics like chamfer distance even on CPU. </p> <h2 id=conclusion ><a href="#conclusion" class=header-anchor >Conclusion</a></h2> <p>As all the batched structure for PointCloud, TriMesh, and VoxelGrid are stable enough, we can easily define any arbitrary or custom functions on top of it and using Zygote we can easily differentiate through it. There are a lot of interesting applications of Flux3D.jl along with other interesting packages in Julia like DiffEqFlux, worth exploring.</p> <p>Some of the things which would be interesting to have in future releases are:-</p> <ul> <li><p>Cache-based Custom dataset wrapper, as 3D data are expensive in terms of space and computation &#40;especially in VoxelGrid&#41;.</p> <li><p>Some more metrics for 3D data like normal<em>consistency, cloud</em>to<em>surface</em>distance and some more loss.</p> <li><p>Add support for textures in case of TriMesh which will open a lot more applications.</p> <li><p>Integration with Differentiable Graphics Frameworks &#40;like RayTracer.jl&#41;</p> </ul> <p>Any suggestions, issues and pull requests are most appreciated. Cheers&#33;</p> <p class=author >– Nirmal Suthar, Avik Pal, Dhairya Gandhi</p> </div> </div> </div> <div class="container footer lighter"> <p>Flux: A Deep Learning Library for the Julia Programming Language </p> <a href="https://twitter.com/FluxML?ref_src=twsrc%5Etfw" class=twitter-follow-button  data-show-count=false >Follow @FluxML</a> <script async src="https://platform.twitter.com/widgets.js" charset=utf-8 ></script> </div> <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script> <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"></script> <script src="/.//instant.page/1.0.0" type=module  integrity="sha384-6w2SekMzCkuMQ9sEbq0cLviD/yR2HfA/+ekmKiBnFlsoSvb/VmQFSi/umVShadQI"></script>