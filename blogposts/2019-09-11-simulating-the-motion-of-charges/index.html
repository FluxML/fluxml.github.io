<!DOCTYPE html> <html lang=en > <style> #cppn{ position:absolute; top:0; bottom:0; height: 100%; width: 100vw; } iframe { display: block; border-style:none; } </style> <meta property="og:title" content=Flux.jl > <meta property="og:description" content="The elegant machine learning library"> <meta property="og:image" content="/assets/images/FluxGitHubPreview.png"> <meta property="og:url" content=fluxml.ai > <meta name="twitter:title" content=Flux.jl > <meta name="twitter:description" content="The elegant machine learning library"> <meta name="twitter:image" content="/assets/images/FluxGitHubPreview.png"> <meta name="twitter:card" content=summary_large_image > <link rel=apple-touch-icon  sizes=180x180  href="assets/favicon_io/apple-touch-icon.png"> <link rel=icon  type="image/png" sizes=32x32  href="assets/favicon_io/favicon-32x32.png"> <link rel=icon  type="image/png" sizes=16x16  href="assets/favicon_io/favicon-16x16.png"> <link rel=manifest  href="assets/favicon_io/site.webmanifest"> <script async src="https://www.googletagmanager.com/gtag/js?id=UA-36890222-9"></script> <script> window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-36890222-9'); </script> <meta charset=utf-8 > <meta name=viewport  content="width=device-width, initial-scale=1, shrink-to-fit=no"> <link rel=stylesheet  href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta/css/bootstrap.min.css" integrity="sha384-/Y6pD6FV/Vv2HJnA6t+vslU6fwYXjCFtcEpHbNJ0lyAFsXTsjBbfaDjzALeQsN6M" crossorigin=anonymous > <link rel=stylesheet  href="../../css/script_default.css"> <link rel=stylesheet  href="../../css/site.css"> <link rel=stylesheet  href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin=anonymous > <link rel=stylesheet  href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css" integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y" crossorigin=anonymous > <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.js" integrity="sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx" crossorigin=anonymous ></script> <script defer src="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/auto-render.min.js" integrity="sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe" crossorigin=anonymous  onload="renderMathInElement(document.body, { delimiters: [ {left: '$[[', right: ']]', display: true}, {left: '\\[', right: '\\]', display: true}, {left: '[[', right: ']]', display: false} ] });"> </script> <title>Flux – Elegant ML</title> <nav class="navbar navbar-expand-lg navbar-dark container lighter"> <a class=navbar-brand  href="/./"> <div class=logo  style="font-size:30pt;margin-top:-15px;margin-bottom:-10px;">flux</div> </a> <button class=navbar-toggler  type=button  data-toggle=collapse  data-target="#navbarSupportedContent" aria-controls=navbarSupportedContent  aria-expanded=false  aria-label="Toggle navigation"> <span class=navbar-toggler-icon ></span> </button> <div class="collapse navbar-collapse" id=navbarSupportedContent > <ul class="navbar-nav mr-auto"> <li class=nav-item > <a class=nav-link  href="https://fluxml.ai/Flux.jl/" target=_blank >Documentation</a> <li class=nav-item > <a class=nav-link  href="https://github.com/FluxML/model-zoo/" target=_blank >Model Zoo</a> <li class=nav-item > <a class=nav-link  href="https://github.com/FluxML/Flux.jl" target=_blank >GitHub</a> <li class=nav-item > <a class=nav-link  href="https://fluxml.ai/Flux.jl/stable/ecosystem/">Ecosystem</a> <!-- <li class=nav-item > <a class=nav-link  href="/./gsod/">GSoD</a> --> <li class=nav-item > <a class=nav-link  href="/./blog/">Blog</a> <li class=nav-item > <a class=nav-link  href="/./gsoc/">GSoC</a> <li> <a class=nav-link  href="/./governance/">Governance</a> <li class=nav-item > <a class=nav-link  href="https://github.com/FluxML/Flux.jl/blob/master/CONTRIBUTING.md" target=_blank >Contribute</a> </ul> </div> </nav> <div class=content > <div class=container > <h1>Simulating the Motion of Charged Bodies</h1> <div class=franklin-content > <blockquote> <p>“We demand rigidly defined areas of doubt and uncertainty&#33;” – Douglas Adams, The Hitchhiker&#39;s Guide To The Galaxy</p> </blockquote> <h2 id=what_do_charges_like_doing ><a href="#what_do_charges_like_doing" class=header-anchor >What do charges like doing?</a></h2> <p>The answer is quite simple: like charges like to move apart and unlike charges like to move closer. If I were to place a 100 charges in a circle of radius 5cm and tell them to do their thing they would contentedly move around so that they attain the most stable state – where the total potential energy of the system is minimum. The problem is that even though charges know what their purpose is in life, and we know more or less what they’d tend to do, it’s quite difficult to predict their exact movements. Most of us can predict the movement of 3 or 4 charged bodies, but when it comes to accounting for the interactions of a 100 charges, the teachings of H.C. Verma and Resnick Halliday aren’t enough to help us.</p> <h2 id=the_main_idea ><a href="#the_main_idea" class=header-anchor >The Main Idea</a></h2> <p>What is the objective of my system of 100 charges? To minimise the total value of this potential energy. &#40;Coincidentally this is the objective of the entire universe as well&#41; What is the objective of a typical machine learning model? To minimise the total cost/loss. Hmm…</p> <p>I’m going to see if I can predict the behaviour of a system of a 100 charges by differentiating the total potential energy and performing gradient descent on the x and y coordinates of each charge. What should happen is that the x and y coordinates start changing themselves to minimise the total potential energy. Therefore, the charges start moving to minimise the total potential energy, mimicking what would happen in the real world.</p> <h2 id=the_obvious_approach_vs_my_approach ><a href="#the_obvious_approach_vs_my_approach" class=header-anchor >The Obvious Approach vs My Approach</a></h2> <h3 id=the_obvious_approach ><a href="#the_obvious_approach" class=header-anchor >The Obvious Approach</a></h3> <p>The solution to this problem that immediately comes to mind is to use the amazing computing power we possess to resolve the vector components of the 99 forces on each of the 100 charges we have, use that net force to predict the acceleration of the charges, use that acceleration to produce movement in the charges, and repeat the process within a very short time interval to produce as continuous and as accurate a movement as possible. </p> <h3 id=my_approach ><a href="#my_approach" class=header-anchor >My Approach</a></h3> <p>Why do charges move? Due to acceleration. Where does acceleration come from? Force. Why is force applied? To lower potential energy. Therefore, it’s potential energy that’s really pulling the strings. What I’ve done is cut out the middleman that is force. I’ve changed my objective from simulating the effect that force has on charged bodies to directly simulating the effect that potential energy has on it. &#40;This may seem like the same thing, and the fact that it does is why I can do it&#41; The main advantage to doing so is that potential energy is a scalar quantity whereas force is a vector. Calculating the net potential energy of a system of 100 charges is a lot easier than calculating the net force on each charge in a 100-charge system.</p> <h2 id=the_science_part_of_it ><a href="#the_science_part_of_it" class=header-anchor >The Science Part of It</a></h2> <p>Let’s look at our classic formula to calculate potential energy</p> \[U = \frac{1}{4 \pi \epsilon_0}\frac{q_1q_2}{r}\] <p>It quantifies the potential energy \(U\) of a system of two point-charges with magnitudes q1 and q2, separated by a distance r in free space &#40;vacuum&#41;.</p> <p>If we want the total potential energy of a system of \(n\) charges, we just apply this formula \(^nC_2\) times.</p> <h2 id=lets_begin ><a href="#lets_begin" class=header-anchor >Let&#39;s Begin</a></h2> <p>I’m going to create a system of 100 charged bodies and initialise them with random charge values. I’m sampling from a Gaussian Distribution since I’d like there to be a few slightly larger charges in the mix to make things interesting.</p> <pre><code class=language-julia >struct Vertex            # represents the charged body
  charge::Float64
  pos::Vector&#123;Float64&#125; # x,y coordinates
end

# Create the req no. of charges with random positions and amplitudes
function create_env&#40;no_ch&#41;
  &#91;Vertex&#40;randn&#40;&#41;, rand&#40;-5:0.001:5, 2&#41;&#41; for _ in 1:no_ch&#93;
end</code></pre> <p>I’m also going to place these charges randomly in a circle of radius 5cm centred at the origin.</p> <p>Later on, I’ll make sure that these charges never leave this circle. Why is this important? If I happen to get a couple of large charges with the same sign and these charges were allowed to go anywhere they wanted to, they would simply move apart to infinity, dragging all the smaller charges with them, and we wouldn’t get to see much.</p> <p>I’m also going to create a simple function to calculate potential.</p> <pre><code class=language-julia >function potential&#40;a::Vertex, b::Vertex&#41; # classic potential formula
  return &#40;8.9e9&#41;*a.charge*b.charge/&#40;sqrt&#40;sum&#40;abs2.&#40;a.pos .- b.pos&#41;&#41;&#41;&#41;
end

function potential&#40;a::Vector&#41; # potential for a system of charges
  pot &#61; 0
  for i in 1:length&#40;a&#41; # nC2
    for j in i&#43;1:length&#40;a&#41;
      pot &#61; pot&#43;potential&#40;a&#91;i&#93;,a&#91;j&#93;&#41;
    end
  end
  return pot
end</code></pre> <p>Now I’m going to define my loss function. Why can’t I just use my potential function? The reason is that I want to constrain my charges to a circle. The way I do that is by applying a high penalty&#40;loss&#41; every time a charge tries to move out of the circle.</p> <pre><code class=language-julia >function loss&#40;env::Vector&#41;
  s &#61; 0
  for i in 1: length&#40;env&#41;
    # if charge moves outside circle of radius 5 centred at origin,
    # give it a high penalty
    # this is to constrain it otherwise large like charges would
    # just go to infinity and we wouldn&#39;t see much
    if distance&#40;env&#91;i&#93;, &#91;0,0&#93;&#41;-5&gt;0          
      s &#61; s&#43;100*&#40;distance&#40;env&#91;i&#93;,&#91;0,0&#93;&#41;-5&#41;        
    end
  end
  # scaling potential so the distance moved is acceptably small
  l &#61;  s &#43; 1.0e-9*potential&#40;env&#41;                      
  return l
end</code></pre> <p>Since the potential function gives a very high value of the order of 10&lt;sup&gt;9&lt;/sup&gt; we need to scale it so that the loss is a low enough value to produce an acceptable movement in my charges.</p> <p>Let’s create the environment of charges</p> <pre><code class=language-julia >env &#61; create_env&#40;100&#41;</code></pre>
<p>I’m using 2 main machine learning libraries. Zygote, for its AD capabilities, and Flux, for its optimisers.</p>
<pre><code class=language-julia >using Zygote
using Flux</code></pre>
<p>Let’s start moving these charges around</p>
<pre><code class=language-julia >opt &#61; ADAM&#40;0.01&#41;
for i in 1:200
  gs &#61; Zygote.gradient&#40;loss, env&#41;
  for j in 1: length&#40;gs&#91;1&#93;&#41; # each j is a charge
    # making sure we update only the positions not the charge value
    Flux.Optimise.update&#33;&#40;opt, env&#91;j&#93;.pos, gs&#91;1&#93;&#91;j&#93;.pos&#41;
  end
end</code></pre>
<p>Using some basic plotting functions, I graphed my charges at every training iteration and put them all together in a gif.</p>
<p><img src="../../assets/charges/maingif.gif" alt="" /></p>
<p><em>Red charges are positive, Blue charges are negative and size of the dot is proportional to the absolute value of charge.</em></p>
<h2 id=the_big_question_it_looks_cool_but_does_it_work ><a href="#the_big_question_it_looks_cool_but_does_it_work" class=header-anchor >The Big Question. It looks cool, but does it work?</a></h2>
<p>A high-level observation shows that the like charges tend to move apart and the unlike charges tend to move closer. We can take a step further and notice that as time progresses, the charges tend to move less and less since they are more or less in a stable position. A sure sign of convergence.</p>
<p>Let’s prove this.</p>
<p>Let’s take a trivial case and define a system of two charges: one positive and one negative. Let’s place them diametrically opposite with respect to the origin.</p>
<p><img src="../../assets/charges/plot1.png" alt="" /></p>
<p>What do we expect to happen? The charges should move together.</p>
<p><img src="../../assets/charges/plot2.png" alt="" /></p>
<p>And they do&#33;</p>
<p><em>&#40;What’s interesting is that they seem to have overshot and actually crossed each other at one point, only to get drawn to each other once more. An apt parallel is charges overshooting due to inertia of motion&#41;</em></p>
<p>Let’s go back to that system of 100 charges and plot the potential energy at every training iteration. <img src="../../assets/charges/plot3.png" alt="" /></p>
<p>It’s safe to say that the system has converged at a value of approximately -1360 .</p>
<p>You’re probably wondering why the graph is so bumpy and what these extreme minimas are. The minimas are simply the points in the training loop when the charges got a bit overconfident and tried to escape the constraining circle. They are then immediately brought back to valid positions by the loss function. They may also occur when a positive and a negative charge briefly overlap with each other giving a potential of negative infinity. Of course, such a situation is impossible in the real world.</p>
<h2 id=conclusion ><a href="#conclusion" class=header-anchor >Conclusion</a></h2>
<p>It works&#33; I created this simulation because it’s an interesting and very visual way to get a real feel of how charges move around when affected by almost a 100 different forces. It also shows how it’s possible to solve a problem more easily by reframing the question being asked. ~~Simulate the effect of force on charged bodies?~~   Simulate the effect of potential energy on charged bodies?   Most of all it shows the power of gradient descent in solving a problem that would be unwieldy to solve using classic approaches.</p>

<p class=author >– Sudhanshu Agrawal sudhanshuagr27@ucla.edu</p>



</div>    

    
      </div>
    </div>
    

    
    <div class="container footer lighter">
      <p>Flux: A Deep Learning Library for the Julia Programming Language
</p>
      <a href="https://twitter.com/FluxML?ref_src=twsrc%5Etfw" class=twitter-follow-button  data-show-count=false >Follow @FluxML</a>
      <script async src="https://platform.twitter.com/widgets.js" charset=utf-8 ></script>
    </div>

    
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.2.0/js/bootstrap.min.js"></script>
    <script src="/./libs/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    
    <script src="/.//instant.page/1.0.0" type=module  integrity="sha384-6w2SekMzCkuMQ9sEbq0cLviD/yR2HfA/+ekmKiBnFlsoSvb/VmQFSi/umVShadQI"></script>